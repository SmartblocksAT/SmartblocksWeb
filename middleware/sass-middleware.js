'use strict';

//
// Took and modified from:
// https://github.com/sass/node-sass-middleware/blob/master/middleware.js
//
// Modified to "just work" with a new version of mkdirp and dart-sass
//
//
// Copyright (c) 2013+ Andrew Nesbitt.
// https://github.com/sass/node-sass-middleware/blob/master/LICENSE
//

const _sass = require('sass');
const util = require('util');
const fs = require('fs');
const url = require('url');
const dirname = require('path').dirname;
const mkdirp = require('mkdirp');
const join = require('path').join;

let imports = {};

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    all supportend options from node-sass project plus following:
 *
 *    `src`            Source directory used to find .scss files
 *    `dest`           Destination directory used to output .css files when undefined defaults to `src`
 *    `root`           A base path for both source and destination directories
 *    `prefix`         It will tell the sass compiler that any request file will always be prefixed
 *                     with <prefix> and this prefix should be ignored.
 *    `force`          Always re-compile
 *    `debug`          Output debugging information
 *    `response`       True (default) to write output directly to response instead of to a file
 *    `error`          A function to be called when something goes wrong
 *    `maxAge`         MaxAge to be passed in Cache-Control header
 *    `log`            function(severity, key, val), used to log data instead of the default `console.error`
 *
 *
 * Examples:
 *
 * Pass the middleware to Connect, grabbing .scss files from this directory
 * and saving .css files to _./public_.
 *
 * Following that we have a `staticProvider` layer setup to serve the .css
 * files generated by Sass.
 *
 *   let server = connect()
 *      .use(middleware({
 *        src: __dirname,
 *        dest: __dirname,
 *      }))
 *      .use(function(err, req, res, next) {
 *        res.statusCode = 500;
 *        res.end(err.message);
 *      });
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function (options) {
    options = options || {};

    // Accept single src/dest dir
    if (typeof options === 'string') {
        options = {src: options};
    }

    // Source directory (required)
    let src = options.src || function () {
        throw new Error('sass.middleware() requires "src" directory.');
    }();
    // Destination directory (source by default)
    let dest = options.dest || src;
    // Optional base path for src and dest
    let root = options.root || null;

    // Force compilation everytime
    let force = options.force || options.response;
    // Enable debug output
    let debug = options.debug;

    let sassExtension = (options.indentedSyntax === true) ? '.sass' : '.scss';

    let sourceMap = options.sourceMap || null;

    let maxAge = options.maxAge || 0;

    //Allow custom log function or default one
    let log = options.log || function (severity, key, val, text) {
        if (!debug && severity === 'debug') { // skip debug when debug is off
            return;
        }

        text = text || '';

        if (typeof (console[severity]) === 'function') {
            console[severity]('[sass]  \x1B[90m%s:\x1B[0m \x1B[36m%s %s\x1B[0m', key, val, text);
        } else {
            console.error('[sass]  \x1B[90m%s:\x1B[0m \x1B[36m%s %s\x1B[0m', key, val, text);
        }
    };

    // Default compile callback
    options.compile = options.compile || function () {
        return sass;
    };

    // Middleware
    // tslint:disable-next-line:no-shadowed-variable
    return function sass(req, res, next) {
        let sassMiddlewareError = null;

        // This function will be called if something goes wrong
        let error = function (err, errorMessage) {
            log('error', 'error', errorMessage || err);

            if (options.error) {
                options.error(err);
            }

            sassMiddlewareError = err;
        };

        if (req.method !== 'GET' && req.method !== 'HEAD') {
            return next();
        }

        let path = url.parse(req.url).pathname;

        if (!/\.css$/.test(path)) {
            log('debug', 'skip', path, 'nothing to do');
            return next();
        }

        if (options.prefix) {
            if (0 === path.indexOf(options.prefix)) {
                path = path.substring(options.prefix.length);
            } else {
                log('debug', 'skip', path, 'prefix mismatch');
                return next();
            }
        }

        let cssPath = join(dest, path);
        let sassPath = join(src, path.replace(/\.css$/, sassExtension));
        let sassDir = dirname(sassPath);

        if (root) {
            cssPath = join(root, dest, path.replace(new RegExp('^' + dest), ''));
            sassPath = join(root, src, path
                .replace(new RegExp('^' + dest), '')
                .replace(/\.css$/, sassExtension));
            sassDir = dirname(sassPath);
        }

        log('debug', 'source', sassPath);
        log('debug', 'dest', options.response ? '<response>' : cssPath);

        // When render is done, respond to the request accordingly
        let done = function (err, result) {
            if (err) {
                let file = sassPath;
                if (err.file && err.file !== 'stdin') {
                    file = err.file;
                }

                let fileLineColumn = file + ':' + err.line + ':' + err.column;
                let errorMessage = '\x07\x1B[31m' + err.message.replace(/^ +/, '') + '\n\nin ' + fileLineColumn + '\x1B[91m';

                error(err, errorMessage);
                return next(err);
            }

            let data = result.css;

            log('debug', 'render', options.response ? '<response>' : sassPath);

            if (sourceMap) {
                log('debug', 'render', this.options.sourceMap);
            }
            imports[sassPath] = result.stats.includedFiles;

            let cssDone = true;
            let sourceMapDone = true;

            function doneWriting() {
                if (!cssDone || !sourceMapDone) {
                    return;
                }

                if (options.response === false) {
                    return next(sassMiddlewareError);
                }

                res.writeHead(200, {
                    'Content-Type': 'text/css',
                    'Cache-Control': 'max-age=' + maxAge,
                });
                res.end(data);
            }

            // If response is true, do not write to file
            if (options.response) {
                return doneWriting();
            }

            cssDone = false;
            sourceMapDone = !sourceMap;

            // tslint:disable-next-line:no-shadowed-variable
            mkdirp(dirname(cssPath), '0700').then(function (d) {
                console.log(err, d);
                if (err) {
                    error(err);
                    cssDone = true;
                    return doneWriting();
                }

                // tslint:disable-next-line:no-shadowed-variable
                fs.writeFile(cssPath, data, 'utf8', function (err) {
                    log('debug', 'write', cssPath);

                    if (err) {
                        error(err);
                    }

                    cssDone = true;
                    doneWriting();
                });
            }).catch(console.error);

            if (sourceMap) {
                let sourceMapPath = this.options.sourceMap;
                // tslint:disable-next-line:no-shadowed-variable
                mkdirp(dirname(sourceMapPath), '0700', function (err) {
                    if (err) {
                        error(err);
                        sourceMapDone = true;
                        return doneWriting();
                    }

                    // tslint:disable-next-line:no-shadowed-variable
                    fs.writeFile(sourceMapPath, result.map, 'utf8', function (err) {
                        log('debug', 'write', sourceMapPath);

                        if (err) {
                            error(err);
                        }

                        sourceMapDone = true;
                        doneWriting();
                    });
                });
            }
        };

        // Compile to cssPath
        let compile = function () {
            fs.exists(sassPath, function (exists) {
                log('debug', 'read', sassPath);

                if (!exists) {
                    log('debug', 'skip', sassPath, 'does not exist');
                    return next();
                }

                imports[sassPath] = undefined;

                // let style = options.compile();

                let renderOptions = util._extend({}, options);

                renderOptions.file = sassPath;
                renderOptions.outFile = options.outFile || cssPath;
                renderOptions.includePaths = [sassDir].concat(options.includePaths || []);
                //
                // style.render(renderOptions, done);
                try {
                    let result = _sass.renderSync(renderOptions);
                    // console.log(result.css);
                    // console.log(result.map);
                    done(undefined, result);
                } catch (e) {
                    done(e, undefined);
                }

            });
        };

        // Force
        if (force) {
            return compile();
        }

        // Re-compile on server restart, disregarding
        // mtimes since we need to map imports
        if (!imports[sassPath]) {
            return compile();
        }

        // Compare mtimes
        fs.stat(sassPath, function (err, sassStats) {
            if (err) { // sassPath can't be accessed, nothing to compile
                log('debug', 'skip', sassPath, 'is unreadable');
                return next();
            }

            // tslint:disable-next-line:no-shadowed-variable
            fs.stat(cssPath, function (err, cssStats) {
                if (err) {
                    if ('ENOENT' === err.code) { // CSS has not been compiled, compile it!
                        log('debug', 'compile', cssPath, 'was not found');
                        return compile();
                    }

                    error(err);
                    return next(err);
                }

                if (sassStats.mtime > cssStats.mtime) { // Source has changed, compile it
                    log('debug', 'compile', sassPath, 'was modified');
                    return compile();
                }

                // Already compiled, check imports
                checkImports(sassPath, cssStats.mtime, function (changed) {
                    if (debug && changed && changed.length) {
                        // tslint:disable-next-line:no-shadowed-variable
                        changed.forEach(function (path) {
                            log('debug', 'compile', path, '(import file) was modified');
                        });
                    }
                    changed && changed.length ? compile() : next();
                });
            });
        });
    };
};

/**
 * Check `path`'s imports to see if they have been altered.
 *
 * @param {String} path
 * @param {Function} fn
 * @param {any} time
 * @api private
 */

function checkImports(path, time, fn) {
    let nodes = imports[path];
    if (!nodes || !nodes.length) {
        return fn();
    }

    let pending = nodes.length;
    let changed = [];

    // examine the imported files (nodes) for each parent sass (path)
    nodes.forEach(function (imported) {
        fs.stat(imported, function (err, stat) {
            // error or newer mtime
            if (err || stat.mtime >= time) {
                changed.push(imported);
            }
            // decrease pending, if 0 call fn with the changed imports
            // tslint:disable-next-line:no-unused-expression
            --pending || fn(changed);
        });
    });
}
